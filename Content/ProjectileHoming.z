// A Projectile that homes on a target
class ProjectileHoming : ScriptComponent
{
    [Dependency]
    var Projectile : Projectile = null;
    
    // The current cog we are targetting.
    var Target : Cog = null;
    
    // The maximum results we can get from the sphere cast.
    // Just a property so it doesn't take memory and whatnot.
    var MaxResults : Integer { get { return 3; } }
    
    constructor() : base()
    {
    }
    
    function Initialize(init : CogInitializer)
    {
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
        Zero.Connect(this.Owner, Events.ProjectileSetup, this.OnSetup);
    }
    
    function OnSetup(e : Event)
    {
        // Find our first target and then queue up the next set of searches
        this.FindTarget();
        this.QueueActions();
    }
    
    function QueueActions()
    {
        // Do a search for a new target at fixed intervals
        var searchInterval = 0.5;
        var seq = Actions.Sequence(this.Owner.Actions);
        Actions.Delay(seq, searchInterval);
        Actions.Call(seq, this.FindTarget);
        Actions.Call(seq, this.QueueActions);
    }
    
    function OnLogicUpdate(updateEvent : UpdateEvent)
    {
        if(this.Target == null)
        {
            return;
        }
        
        this.AimTowardsTarget();
    }
    
    function AimTowardsTarget()
    {
        var body = this.Owner.RigidBody;
        var orientation = this.Owner.Orientation;
        // Keep the old magnitude of the velocity so we preserve our speed
        var oldSpeed = Math.Length(body.Velocity);
        
        var forward = orientation.WorldForward;
        var desiredForward = this.Target.Transform.WorldTranslation - this.Owner.Transform.WorldTranslation;
        // Compute the new forward by interpolating slowly towards the desired forward
        var interpolationFraction = 0.1;
        var newForward = Math.RotateTowards(forward, desiredForward, interpolationFraction);
        // Make sure we have no z-component (just because)
        newForward.Z = 0.0;
        
        orientation.LookAtDirection(newForward);
        body.Velocity = newForward * oldSpeed;
    }
    
    function GetSearchRadius() : Real
    {
        // Hardcoded for now, use a curve later?
        return 5.0;
    }
    
    function FindTarget()
    {
        var pos = this.Owner.Transform.WorldTranslation;
        
        var radius = this.GetSearchRadius();
        var physicsSpace = this.Space.PhysicsSpace;
        // Cast a sphere and find the object in that sphere closest to our current position
        var filter = physicsSpace.CreateDefaultCastFilter();
        var results = physicsSpace.CastSphereResults(pos, radius, this.MaxResults, filter);
        
        var minDistance = 999.0;
        var closestObj : Cog = null;
        foreach(var result in results)
        {
            // Get the object we hit and how close it is to our current position
            var hitObj = result.ObjectHit;
            var objPos = hitObj.Transform.WorldTranslation;
            var distance = Math.Length(objPos - pos);
            
            // If it's further away than our closest result, we don't care
            if(distance > minDistance)
            {
                continue;
            }
            
            // We only objects with health components
            if(hitObj.Health == null)
            {
                continue;
            }
            
            // See if the object we hit has a core link
            var hitRoot = hitObj.FindRoot();
            var coreLink = hitRoot.CoreLink;
            // If it doesn't have a core link, just target it (something like an asteroid)
            if(coreLink == null)
            {
                minDistance = distance;
                closestObj = result.ObjectHit;
                continue;
            }
            
            // If it does have a core link, make sure we aren't targetting an
            // object that belongs to the core that shot us
            if(this.Projectile.CoreCog != coreLink.CoreCog)
            {
                minDistance = distance;
                closestObj = result.ObjectHit;
            }
        }
        
        this.Target = closestObj;
    }
}
